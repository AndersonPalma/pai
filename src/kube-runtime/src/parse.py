#!/usr/bin/env python

import os
import sys
import collections
import logging
import argparse

import json

log = logging.getLogger(__name__)

def get_container_port(envs, name):
    for env in envs:
        if env["name"] == name:
            return env["value"]
    return None

def export(k, v):
    print "export %s='%s'" % (k, v)

# generate runtime environment variables:
# PAI_CURRENT_TASK_ROLE_CURRENT_TASK_INDEX
# PAI_HOST_IP_$taskRole_$taskIndex

# These two variables are legacy, subject to removal
# PAI_TASK_ROLE_$name_HOST_LIST
# PAI__$taskRole_$currentTaskIndex_$type_PORT
def gen_runtime_env(args):
    index_id = os.environ.get("FC_TASK_INDEX")

    if index_id is None:
        log.error("expect FC_TASK_INDEX set as environment variable")
    else:
        export("PAI_CURRENT_TASK_ROLE_CURRENT_TASK_INDEX", index_id)

    log.info("loading json from %s", args.framework_json)

    with open(args.framework_json) as f:
        framework = json.load(f)

    # key is role_name, value is its PAI_CURRENT_CONTAINER_PORT val
    role_cur_port_map = {}
    # key is role_name, value is its PAI_CONTAINER_HOST_PORT_LIST val
    role_ports_map = {}

    # key is role_name, value is task count in this role
    role_task_cnt = {}

    for role in framework["spec"]["taskRoles"]:
        role_name = role["name"]
        cur_port = get_container_port(
                role["task"]["pod"]["spec"]["containers"][0]["env"],
                "PAI_CURRENT_CONTAINER_PORT")
        ports = get_container_port(
                role["task"]["pod"]["spec"]["containers"][0]["env"],
                "PAI_CONTAINER_HOST_PORT_LIST")

        role_cur_port_map[role_name] = cur_port
        role_ports_map[role_name] = ports
        role_task_cnt[role_name] = role["taskNumber"]

    log.info("role_cur_port_map is %s, role_ports_map is %s",
            role_cur_port_map, role_ports_map)

    # key is role name, value is a map with key of index, value of ip
    role_status_map = collections.defaultdict(lambda : {})

    for role_status in framework["status"]["attemptStatus"]["taskRoleStatuses"]:
        name = role_status["name"]
        for status in role_status["taskStatuses"]:
            role_status_map[name][status["index"]] = status["attemptStatus"]["podIP"]

    log.info("role_status_map is %s", role_status_map)

    role_host_port_map = {}
    for role_name, status in role_status_map.items():
        port = role_cur_port_map[role_name]
        ip_ports = []
        for i in xrange(len(status)):
            ip_ports.append(status[i] + ":" + str(port))
        role_host_port_map[role_name] = ",".join(ip_ports)

    # generate
    for role_name, idx_map in role_status_map.items():
        for idx, ip in idx_map.items():
            export("PAI_HOST_IP_%s_%d" % (role_name, idx), ip)

    # following is legacy, subject to removal
    for role_name, host_port_list in role_host_port_map.items():
        export("PAI_TASK_ROLE_%s_HOST_LIST" % role_name, host_port_list)

    for role_name, ports in role_ports_map.items():
        ports = ports.split(";")
        for label_port in ports:
            label, port = label_port.split(":")
            for i in xrange(role_task_cnt[role_name]):
                export("PAI_%s_%d_%s_PORT" % (role_name, i, label), port)

if __name__ == '__main__':
    logging.basicConfig(format="%(asctime)s - %(levelname)s - %(filename)s:%(lineno)s - %(message)s",
            level=logging.INFO)
    parser = argparse.ArgumentParser()
    parser.add_argument("framework_json", help="framework.json path generated by frameworkbarrier")
    args = parser.parse_args()

    gen_runtime_env(args)
